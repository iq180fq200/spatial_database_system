#pragma once
#include <string>
#include "Geometry.h"
#include "QuadTree.h"//to include the defination of feature

#define FANSOUT 20
#define MIN 10
namespace hw6 {

/*
 * RTreeNode hierarchy
 */
	class RTreeNode {
	protected:
		Envelope bbox;
	public:
		RTreeNode() {}
		virtual ~RTreeNode() {}
		virtual bool  isLeafNode()const = 0;
		virtual RTreeNode* addLeaf(RTreeNode* child)=0;
		virtual void rangeQuery(Envelope& rect, vector<Feature>& features)=0;
		virtual void spatialJoin(Feature& road, vector<Feature>& points) = 0;
		Envelope& getBbox() { return bbox; }
		virtual void draw()=0;
        virtual void NNQuery(double x, double y, vector<Feature>& features) = 0;
	};

	class RTreeLeafNode : public RTreeNode {
	private:
		Feature feature;

	public:
		RTreeLeafNode(Feature& _feature) :feature(_feature) {
			bbox = feature.getEnvelope();
		}
		bool isLeafNode()const { return true; }
		const Envelope& getEnvelope() { return bbox; }
		Feature& getFeature() { return feature; }
		RTreeNode* addLeaf(RTreeNode* child);
		void spatialJoin(Feature& road, vector<Feature>& points);
		void rangeQuery(Envelope& rect, vector<Feature>& features);
        void NNQuery(double x, double y, vector<Feature>& features);
		void draw();
	};

	class RTreeNonLeafNode : public RTreeNode {
	private:
		RTreeNode* nodes[FANSOUT];
		int nodeNum;

	public:
		RTreeNonLeafNode(RTreeNode* _nodes[], int num) {
            nodeNum = num;
            nodes[0] = _nodes[0];
            //combine the bbox
            bbox = _nodes[0]->getBbox();
			for (int i = 1; i < FANSOUT && i < num; i++) {
				nodes[i] = _nodes[i];
				//combine the bbox
				bbox = _nodes[i]->getBbox().unionEnvelope(bbox);
			}
		}

		~RTreeNonLeafNode() {
			for (int i = 0; i < nodeNum; ++i) {
				delete nodes[i];
				nodes[i] = NULL;
			}
		}

		bool isLeafNode()const { return false; }

		const Envelope& getEnvelope() { return bbox; }

		RTreeNode& getChildNode(size_t i) { return *nodes[i]; }

		//if there is an extra node generated by the child, then add node
		RTreeNode* addLeaf(RTreeNode* child);

		//split it into two nodes, and then renew the parent node
		RTreeNode* split(RTreeNode* extraNode);
		void rangeQuery(Envelope& rect, vector<Feature>& features);
		void spatialJoin(Feature& road, vector<Feature>& points);
        void NNQuery(double x, double y, vector<Feature>& features);
		int getNodeNum() { return nodeNum; };
		void draw();
	};

	class RTree {
	private:
		RTreeNode* root;
		Envelope bbox;

	public:
		RTree() : root(NULL){}
		RTree(RTreeNode* _root):root(_root){}
		~RTree() {
			delete root;
			root = NULL;
		}

		const Envelope& getEnvelope() const { return bbox; }

		bool constructRTree(vector<Feature>& features);

		//fill features with all the possible features
		void rangeQuery(Envelope& rect, vector<Feature>& features);

		//fill features with all the possible features
		bool NNQuery(double x, double y, vector<Feature>& features);

		void spatialJoin(Feature& road, vector<Feature>& points);

		void draw();

		//some extra functions for bonus
		bool addtoRTree(vector<Feature>& features);
		bool addtoRTree(Feature feature);
		//bool deleteFromRTree();
	};

}
