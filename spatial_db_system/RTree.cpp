#include"RTree.h"
#define INFINITE 32767
using namespace hw6;
bool hw6::RTree::constructRTree(vector<Feature>& features)
{
	addtoRTree(features);
	return true;
}

void hw6::RTree::rangeQuery(Envelope& rect, vector<Feature>& features)
{
	if (!root)
		return;
	root->rangeQuery(rect, features);
}

bool hw6::RTree::NNQuery(double x, double y, vector<Feature>& features)
{
    if (!root)
        return false;
    root->NNQuery(x,y, features);
    return true;
}

void hw6::RTree::spatialJoin(Feature& road, vector<Feature>& points)
{
	if (!root)
		return;
	root->spatialJoin(road, points);
}

void hw6::RTree::draw()
{
	if (root)
		root->draw();
}

bool hw6::RTree::addtoRTree(vector<Feature>& features)
{
	int featureSize = features.size();
	for (int i = 0; i < featureSize; i++)
		addtoRTree(features[i]);
	return true;
}

bool hw6::RTree::addtoRTree(Feature feature)
{
	RTreeLeafNode* t=new RTreeLeafNode(feature);
    if (!root)
        bbox = feature.getEnvelope();
    else {
        bbox = bbox.unionEnvelope(feature.getEnvelope());
    }
	if (root == NULL) {
		//create a new leaf node
		root = t;
		return true;
	}
	//if the root is not null
	RTreeNode* extraNode=root->addLeaf(t);
	//if need to grow the root
	if (extraNode) {
		RTreeNode* rTreeNodes[2];
		rTreeNodes[0] = root;//the old root
		rTreeNodes[1] = extraNode;
		RTreeNonLeafNode* newRoot = new RTreeNonLeafNode(rTreeNodes,2);
		root = newRoot;
		return true;
	}
	return false;
}

RTreeNode* hw6::RTreeNonLeafNode::addLeaf(RTreeNode* child)
{
	//to enlarge the box
	Envelope& childBox = child->getBbox();
	bbox = bbox.unionEnvelope(childBox);
	//if the next layer is leaf, then do not need to find
	RTreeNode* pExtraNode = NULL;
	if (nodes[0]->isLeafNode())
		pExtraNode=nodes[0]->addLeaf(child);
	//find a suitable child to insert
	else {
		double minExtendArea = INFINITE;
		int minContain = INFINITE;//if more than one node contain child, then choose the one with the least elements
		int minContainNodeNum = -1;
		int minExtendNum = -1;
		for (int i = 0; i < nodeNum; i++) {
			Envelope bBoxi = nodes[i]->getBbox();
			int tNodeNum = (dynamic_cast<RTreeNonLeafNode*>(nodes[i]))->getNodeNum();
			if (bBoxi.contain(childBox)) {
				minExtendArea = 0;
				if (tNodeNum < minContain) {
					minContain = tNodeNum;
					minContainNodeNum = i;
				}
			}
			else {
				Envelope tryEnvelope = bBoxi.unionEnvelope(childBox);
				double tExtentArea = (tryEnvelope.getHeight() * tryEnvelope.getWidth())\
					- (bBoxi.getHeight() * bBoxi.getWidth());
				if (tExtentArea < minExtendArea) {
					minExtendArea = tExtentArea;
					minExtendNum = i;
				}	
			}
		}
		if (minContainNodeNum >= 0)
			pExtraNode=nodes[minContainNodeNum]->addLeaf(child);
		else
			pExtraNode=nodes[minExtendNum]->addLeaf(child);
	}
	//deal with the divided node from the child
	if (pExtraNode!=NULL) {
		//if I'm not full
		if (nodeNum < FANSOUT) {
			nodes[nodeNum++] = pExtraNode;
			return NULL;
		}
		//if I'm also full, then divide myself, and pass the extra node to my parents
		else {
			RTreeNode* newSibling = split(pExtraNode);
			return newSibling;
		}
	}
	return NULL;
}

//input:the extraNode generated by the division of my child
//output: the extraSibling generated by the division of myself
RTreeNode* hw6::RTreeNonLeafNode::split(RTreeNode* pExtraNode)
{
	//assign all the child to a new parent
	RTreeNode* p1Children[FANSOUT];//store the new groups
	int p1ChildrenNum = 0;
	RTreeNode* p2Children[FANSOUT];
	int p2ChildrenNum = 0;

	//1 if it hasn't been assigned
	bool unAssignedNode[FANSOUT + 1];
	for (int i = 0; i < FANSOUT+1; i++)
		unAssignedNode[i] = true;

    //find the seeds
    double dAreamax = -INFINITE;
    int seed1Num, seed2Num;//the num of seed1 and seed2,if is the extraNode,then the corresponding num is FANSOUT
    Envelope seed1Box, seed2Box;
    for (int i = 0; i < nodeNum; i++) {
        Envelope bBox1 = nodes[i]->getBbox();
        Envelope bBox2;
        if (i == nodeNum - 1) {
            bBox2 = pExtraNode->getBbox();
        }
        else
            bBox2 = nodes[i + 1]->getBbox();
        Envelope tryEnvelope = bBox1.unionEnvelope(bBox2);
        double dArea = tryEnvelope.getArea() - bBox1.getArea() - bBox2.getArea();
        if (dArea > dAreamax) {
            seed1Num = i;
            seed1Box = bBox1;
            seed2Num = i + 1;
            seed2Box = bBox2;
            dAreamax = dArea;
        }
    }

    //assign the two seeds into the group
    if (seed1Num != FANSOUT)
        p1Children[p1ChildrenNum++] = nodes[seed1Num];
    else
        p1Children[p1ChildrenNum++] = pExtraNode;
	unAssignedNode[seed1Num] = false;
    if (seed2Num != FANSOUT)
        p2Children[p2ChildrenNum++] = nodes[seed2Num];
    else
        p2Children[p2ChildrenNum++] = pExtraNode;
	unAssignedNode[seed2Num] = false;

	//assign every node that haven't been assgned
	while (p1ChildrenNum+p2ChildrenNum<FANSOUT+1) {
		//if one is too less,then directly assin leftovers to the other group
		if (p1ChildrenNum == FANSOUT + 1 - MIN) {
			for (int i = 0; i < nodeNum; i++) {
				if (unAssignedNode[i]) {
					p2Children[p2ChildrenNum++] = nodes[i];
					unAssignedNode[i] = false;
					seed2Box = seed2Box.unionEnvelope(nodes[i]->getBbox());
				}
			}
			if (unAssignedNode[FANSOUT]) {
				p2Children[p2ChildrenNum++] = pExtraNode;
				unAssignedNode[FANSOUT] = false;
				seed2Box = seed2Box.unionEnvelope(pExtraNode->getBbox());
			}
			break;
		}
		if (p2ChildrenNum == FANSOUT + 1 - MIN) {
			for (int i = 0; i < nodeNum; i++) {
				if (unAssignedNode[i]) {
					p1Children[p1ChildrenNum++] = nodes[i];
					unAssignedNode[i] = false;
					seed1Box = seed1Box.unionEnvelope(nodes[i]->getBbox());
				}
			}
			if (unAssignedNode[FANSOUT]) {
				p1Children[p1ChildrenNum++] = pExtraNode;
				unAssignedNode[FANSOUT] = false;
				seed1Box = seed1Box.unionEnvelope(pExtraNode->getBbox());
			}
			break;
		}
		
		
		//find next node to assign
		int nextAssignNode = -1;
		int nextAssignP = -1;
		int maxD = -1;

		for (int i = 0; i < nodeNum; i++) {
			if (!unAssignedNode[i])
				continue;
			Envelope tryEnvelope1 = seed1Box.unionEnvelope(nodes[i]->getBbox());
			double tExtentArea1 = tryEnvelope1.getArea() - nodes[i]->getBbox().getArea();
			Envelope tryEnvelope2 = seed2Box.unionEnvelope(nodes[i]->getBbox());
			double tExtentArea2 = tryEnvelope2.getArea() - nodes[i]->getBbox().getArea();
			int D = abs(tExtentArea1 - tExtentArea2);
			if (D > maxD) {
				nextAssignNode = i;
				nextAssignP = tExtentArea1 < tExtentArea2 ? 1 : 2;
				maxD = D;
			}
		}
		if (unAssignedNode[FANSOUT]) {
			Envelope bBoxExtraNode = pExtraNode->getBbox();
			Envelope tryEnvelope1 = seed1Box.unionEnvelope(bBoxExtraNode);
			double tExtentArea1 = tryEnvelope1.getArea() - bBoxExtraNode.getArea();
			Envelope tryEnvelope2 = seed2Box.unionEnvelope(bBoxExtraNode);
			double tExtentArea2 = tryEnvelope2.getArea() - bBoxExtraNode.getArea();
			int D = abs(tExtentArea1 - tExtentArea2);
			if (D > maxD) {
				nextAssignNode = FANSOUT;
				nextAssignP = tExtentArea1 < tExtentArea2 ? 1 : 2;
				maxD = D;
			}
		}

		//assin next node
		if (nextAssignP == 1) {
			unAssignedNode[nextAssignNode] = false;
			if (nextAssignNode == FANSOUT) {
				p1Children[p1ChildrenNum++] = pExtraNode;
				seed1Box = seed1Box.unionEnvelope(pExtraNode->getBbox());
			}
			else {
				p1Children[p1ChildrenNum++] = nodes[nextAssignNode];
				seed1Box = seed1Box.unionEnvelope(nodes[nextAssignNode]->getBbox());
			}	
		}

		if (nextAssignP == 2) {
			unAssignedNode[nextAssignNode] = false;
			if (nextAssignNode == FANSOUT) {
				p2Children[p2ChildrenNum++] = pExtraNode;
				seed2Box = seed2Box.unionEnvelope(pExtraNode->getBbox());
			}
			else {
				p2Children[p2ChildrenNum++] = nodes[nextAssignNode];
				seed2Box = seed2Box.unionEnvelope(nodes[nextAssignNode]->getBbox());
			}
		}
	}
	
	//create the new extra parent nodes(namely the sibling of this)
	RTreeNonLeafNode* newNode = new RTreeNonLeafNode(p2Children, p2ChildrenNum);
	//renew the children,bbox,childnum of myself as a parent node
	for (int i = 0; i < nodeNum; ++i) {
		nodes[i] = NULL;
	}
	nodeNum = p1ChildrenNum;
    for (int i = 0; i < p1ChildrenNum; i++)
        nodes[i] = p1Children[i];
	bbox= nodes[0]->getBbox();
	for (int i = 1; i < FANSOUT && i < nodeNum; i++) {
		//combine the bbox
		bbox = nodes[i]->getBbox().unionEnvelope(bbox);
	}
	return newNode;
}

void hw6::RTreeNonLeafNode::rangeQuery(Envelope& rect, vector<Feature>& features)
{
	if (!bbox.intersect(rect))
		return;
	// Task range query
	// Write your code here
	for (int i = 0; i < nodeNum; ++i) {
		nodes[i]->rangeQuery(rect, features);
	}
}

void hw6::RTreeNonLeafNode::spatialJoin(Feature& road, vector<Feature>& points)
{
	if (bbox.intersect(road.getEnvelope()))
	{
		for (int i = 0; i < nodeNum; i++) {
			nodes[i]->spatialJoin(road, points);
		}
	}
	else return;
}

void hw6::RTreeNonLeafNode::NNQuery(double x, double y, vector<Feature>& features)
{
    double minMaxDistance = INFINITE;
    double minDistance[FANSOUT];
    double maxDistance[FANSOUT];
    for (int i = 0; i < nodeNum; i++) {
        maxDistance[i] = nodes[i]->getBbox().maxDistance2Envelope(x, y);
        minDistance[i] = nodes[i]->getBbox().minDistance2Envelope(x, y);
        if (maxDistance[i] < minMaxDistance)
            minMaxDistance = maxDistance[i];
    }
    for (int i = 0; i < nodeNum; i++) {
        if (minDistance[i] <= minMaxDistance)
            nodes[i]->NNQuery(x, y, features);
    }

}

void hw6::RTreeNonLeafNode::draw()
{
	bbox.draw();
	for (int i = 0; i < nodeNum; ++i)
		nodes[i]->draw();
}


RTreeNode* hw6::RTreeLeafNode::addLeaf(RTreeNode* child)
{
	//must be full and have to split
	return child;
}

void hw6::RTreeLeafNode::spatialJoin(Feature& road, vector<Feature>& points)
{
	double minPossiDistance = INFINITE;
	Envelope enve1 = road.getEnvelope();
	Envelope enve2 = bbox;
	double t;
	if(enve1.contain(bbox))
		points.push_back(feature);
	else
	{
		//leftbottom
		if ((t = enve1.minDistance2Envelope(bbox.getMinX(), bbox.getMinY())) < minPossiDistance)
			minPossiDistance = t;
		//leftup
		if ((t = enve1.minDistance2Envelope(bbox.getMinX(), bbox.getMaxY())) < minPossiDistance)
			minPossiDistance = t;
		//rightup
		if ((t = enve1.minDistance2Envelope(bbox.getMaxX(), bbox.getMaxY())) < minPossiDistance)
			minPossiDistance = t;
		//rightbottom
		if ((t = enve1.minDistance2Envelope(bbox.getMaxX(), bbox.getMinY())) < minPossiDistance)
			minPossiDistance = t;

		if (minPossiDistance > 0.001)
			return;
		points.push_back(feature);
	}
	
}

void hw6::RTreeLeafNode::rangeQuery(Envelope& rect, vector<Feature>& features)
{
	if (!bbox.intersect(rect))
		return;
	features.push_back(feature);
	return;
}

void hw6::RTreeLeafNode::NNQuery(double x, double y, vector<Feature>& features)
{
    features.push_back(feature);
}

void hw6::RTreeLeafNode::draw()
{
	bbox.draw();
	return;
}

RTreeNode* hw6::RTreeNode::addLeaf(RTreeNode* child)
{
	return nullptr;
}
